<#--
  Copyright (c) 2016 Bernd Wengenroth
  Licensed under the MIT License.
  See LICENSE file for details.
-->
<#include "HelperFunctions.fm">
<#assign Clazz = namespace.GName>
/************************************
 * ${file.name}
 *
 * Schema Object for ${namespace.uri}
 *
 * Implementation
 *
<#list namespace.documentation.lines as docLine>
 * ${c_comment_string(docLine)}
</#list>
 *
 * Generated by XmlPGen (c) 2013-2016 Bernd Wengenroth
 * ${timestamp()}   
 */
#include ${MakeLocalPath(namespace.SchemaHPP.GPath)}
#include "XmlPGen/TTypeProxy.h"
#include ${MakeLocalPath(namespace.root.type.WriterHPP.GPath)}

namespace ${NAMESPACE}
{

   static ::XmlPGen::TokenMap const sTokenMap 
   {
     <#list namespace.lookup.chars?chunk(5) as charline>
     <#list charline as tc>{${tc.char?switch('\x0',' 0 ',"'"+tc.char+"'")}, ${tc.next?left_pad(3)}, ${tc.id?left_pad(3)} }<#sep>,</#list><#sep>,
     </#list>
   };

   ${Clazz}::${Clazz}()
   : Schema( ${c_string(namespace.uri)}, static_cast<int>(EToken::${namespace.uri_token.tokenName?capitalize}), static_cast<int>(EToken::${namespace.root_token.tokenName?capitalize}) )
   {
     root = ${resolvePtrNewFromTemplate(namespace.root.type, "TypeHPP")};
   }

   ::XmlPGen::TypeHandler * ${Clazz}::createRootHandler() const
   {
      return XmlPGen::TTypeProxy< ${resolveTypeNameFromTemplate( namespace.root.type, "TypeHPP" )} >::createHandler( ${resolvePtrGetPtr("root")});
   }

   ::XmlPGen::TokenChar const * ${Clazz}::getTokenMap() const
   { 
      return sTokenMap;
   }
   
   void ${Clazz}::writeDocument( ::XmlPGen::AbstractWriter & aw )
   {
      aw.header();
      if ( root )
      {
        aw.start( "${getElementName(namespace.root)}" );
        ::XmlPGen::write( *root, aw );
        aw.end();
      }
   }
   

} // End of namespace ${namespace.name} 
 