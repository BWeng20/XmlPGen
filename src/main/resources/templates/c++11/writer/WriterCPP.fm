<#--
  Copyright (c) 2016 Bernd Wengenroth
  Licensed under the MIT License.
  See LICENSE file for details.
-->
<#include "../HelperFunctions.fm">
<#assign Clazz = type.GName
         NAMESPACE = "XmlPGen">
/************************************
 * ${file.name}
 *
 * Writer for ${type.namespace.uri} ${type.name}
 *
 * Implementation
 *
 * Generated by XmlPGen (c) 2013-2016 Bernd Wengenroth
 * ${timestamp()}
 */
#include "XmlPGen/IsSet.h"
#include "XmlPGen/ToString.h"
#include ${MakeLocalPath(type.WriterHPP.GPath)}
<#assign incList = GetGeneratedPaths("WriterHPP",type.GSubTypes)>
<#list  incList as inc>
#include ${inc}
</#list>

namespace ${NAMESPACE}
{
   void write( ::${type.namespace.name}::${type.TypeHPP.GName} const & e, AbstractWriter & writer )
   {
<#list type.attributes as attribute>
 <#assign MemName  = getAttributeName(attribute)
          MemVar   = getAttributeVarName(attribute)>
 <#if options.generate.getters == true>
  <#assign AttrGet = "e.get"+MemName+"()" > 
 <#else>
  <#assign AttrGet = "e."+MemVar > 
 </#if>
 <#if !attribute.requiered>
     if ( ::XmlPGen::isSet( ${AttrGet} ) )
        writer.attribute( "${attribute.name}", ${resolveCPtrValue( attribute, AttrGet)} );
 <#else>
     writer.attribute( "${attribute.name}", ${resolveCPtrValue( attribute, AttrGet)} );
 </#if>
</#list>
<#list type.members as member>
 <#assign TypeName = resolveTypeName(member.type)
          MemName  = getElementName(member)
          MemVar   = getElementVarName(member)>
 <#if options.generate.getters == true>
  <#assign MemGet = "e.get"+MemName+"()" > 
 <#else>
  <#assign MemGet = "e."+MemVar > 
 </#if>
 <#if member.type.isEnumeration>     
   <#if member.occurence.optional>
     writer.element_none_empty( "${member.name}", ${resolveTypeNameFromTemplate(member.type,"TypeHPP")?remove_ending("::Type")}::toString(${MemGet}) );
   <#else>
     writer.element( "${member.name}", ${resolveTypeNameFromTemplate(member.type,"TypeHPP")?remove_ending("::Type")}::toString(${MemGet}) );
   </#if>
 <#else>
  <#if isListMember(member)>
   <#if options.generate.getters == true>
     for (int32_t i=0 ; i< e.get${MemName}Count(); ++i )
     {
       auto const & em_ = e.get${MemName}(i);
   <#else>
     for (auto const & em_ : e.${MemVar} )
     {
   </#if>
     <#if member.type.atomic>
       writer.element( ${resolveElementName(member,"em_")}, ${resolveCPtrValue( member, "em_")} );
     <#else>
       writer.start( ${resolveElementName(member,"em_")} );
       <#if member.type.usage == "ByPointer">
       write( *em_, writer );
       <#else>
       write( em_, writer );
       </#if>       
       writer.end();
     </#if>       
     }
  <#else>
     
   <#if member.type.usage == "ByPointer">
     if ( ${MemGet} ) 
     {  
        writer.start( "${member.name}" );
        write( *(${MemGet}), writer );
        writer.end();
     }
   <#else>
     <#if member.occurence.optional>
     if ( ::XmlPGen::isSet( ${MemGet} ) )
     </#if>
     {
       writer.start( "${member.name}" );
     <#if member.type.atomic>
       writer.content( ${resolveCPtrValue( member, MemGet)} );
     <#else>
       write( ${MemGet}, writer );
     </#if>
       writer.end();
     }
    </#if>
   </#if>
  </#if>
 </#list>
   }
 
} // end of namespace
 