<#--
  Copyright (c) 2016 Bernd Wengenroth
  Licensed under the MIT License.
  See LICENSE file for details.
-->
<#include "HelperFunctions.fm">
<#assign Clazz = type.GName>
<#assign mpad = options.generate.member.padding?number>
<#assign memberIndex = 0 >
<#function insertSetFlag >
  <#if options.generate.setflags>
    <#return "setFlags.set("+memberIndex+");">
  <#else>
    <#return "">
  </#if>
</#function>
<#function insertSetFlagCheck val>
  <#if options.generate.setflags>
    <#return "setFlags.set("+memberIndex+","+resolvePtrCheckNull(val)+");">
  <#else>
    <#return "">
  </#if>
</#function>
#ifndef ${resolveIncludeDefine()}
#define ${resolveIncludeDefine()}
/************************************
 * ${file.name}
 *
 * Accessor for ${c_comment_string(type.namespace.uri)} ${type.name}
 *
 * Generated by XmlPGen (c) 2013-2016 Bernd Wengenroth
 * ${timestamp()}
 */
 <#-- Get list of generated files of this template-type for all subtypes 
      of the current type. -->
<#assign incList = GetGeneratedPaths("TypeHPP",type.GSubTypes)?sort>
<#list  incList as inc>
#include ${inc}
</#list>
<#if options.generate.setflags && !type.isEnumeration>
#include <bitset>
</#if>    
  
 namespace ${NAMESPACE}
 {
<#if ((type.documentation.lines?size) > 0) >
    /**
 <#list type.documentation.lines as docLine>
     * ${c_comment_string(docLine)}
 </#list>
     */ 
</#if>
    class ${Clazz}
    {
    public:
     <#if type.isEnumeration>
        enum Type 
        {
<#assign epad = max(16,type.enumeration.maxlength)>
<#list type.enumeration.values as enumValue>
<#-- available properties:
            value:       Raw value from xsd, e.g. '3some-val1', 'myVal2'
            GValue:      Normalised value, usable as symbol, e.g. '_3some_val1', 'myVal2'
            GTypedValue: Normalised value with uppercase type-prefix, e.g. 'MYTYPE_3some_val1', 'MYTYPE_myVal2'
            GEValue:     Normalised value with 'E' prefix, e.g. 'E3some_val1', 'EMyVal2'
-->
<#-- Will place the enum annotation at the right side. Looks pretty, but IDEs will not connect the comments to the value.
            ${enumValue.GEValue},<#list enumValue.documentation.lines as line><#assign docLine = c_comment_string(line)> <#if line?is_first>${" "?right_pad(epad-(enumValue.GEValue?length))} /* <#else>
            ${" "?right_pad(epad)}     </#if>${docLine?trim}<#if line?is_last> */</#if></#list>
-->
            <#list enumValue.documentation.lines as docLine>
            <#if docLine?is_first>/* <#else>   </#if>${c_comment_string(docLine)?trim}<#if docLine?is_last > */</#if>
            </#list>
            ${enumValue.GEValue},
</#list>
            NUMBER_OF_VALUES, // Number of enumeration values for ${type.name}.
            UNSET             // for uninitizalised or wrong values. Will be translated to an empty string.
        };

        static Type parse( char const * const );
        static char const * toString( Type );
     <#else>
<#if options.generate.ctor == true>
        ${Clazz}();
</#if>
<#if options.generate.copyctor == true>
        ${Clazz}( const ${Clazz} & );
</#if>
<#if options.generate.assignment == true>
        ${Clazz} & operator = ( const ${Clazz} & );
</#if>
<#if options.generate.compare == true>
        bool operator == ( const ${Clazz} & ) const;
</#if>
<#if options.generate.getters == true>
<#list type.attributes as attribute>
 <#assign MemName  = getAttributeName(attribute)>
 <#assign MemVar   = getAttributeVarName(attribute)>
 <#if attribute?is_first>

        //////////////////////////////////////////////
        // Attributes
 </#if>

 <#if attribute.type.usage == "ByPointer">
        inline ${resolvePtrType(attribute.type)} const ${getAttributeGetter(attribute)}() const { return ${MemVar}; }
        inline ${resolvePtrType(attribute.type)} const ${getAttributeGetter(attribute)}()       { return ${MemVar}; }
  <#if options.generate.setters == true>
        inline void ${getAttributeSetter(attribute)}( ${resolvePtrType(attribute.type)} p) { ${MemVar} = p; ${insertSetFlagCheck("p")}}
  </#if>
 <#elseif attribute.type.usage == "ByReference">
        inline ${resolveTypeName(attribute.type)} const & ${getAttributeGetter(attribute)}() const { return ${MemVar}; }
        inline ${resolveTypeName(attribute.type)}       & ${getAttributeGetter(attribute)}()       { return ${MemVar}; }
  <#if options.generate.setters == true>
        inline void ${getAttributeSetter(attribute)}( const ${resolveTypeName(attribute.type)} &r) { ${MemVar} = r; ${insertSetFlag()}}
  </#if>
 <#else>
        inline ${resolveTypeName(attribute.type)} ${getAttributeGetter(attribute)}() const { return ${MemVar}; }
  <#if options.generate.setters == true>
        inline void ${getAttributeSetter(attribute)}(${resolveTypeName(attribute.type)} v) { ${MemVar} = v; ${insertSetFlag()}}
  </#if>
 </#if>
 <#if options.generate.setflags>
        inline void ${getAttributeClear(attribute)}() { setFlags.reset( ${memberIndex} ); }
        inline bool ${getAttributeIsSet(attribute)}() const { return setFlags.test( ${memberIndex} ); }
        <#assign memberIndex = memberIndex + 1 >
 </#if>
</#list>
<#list type.members as member>
<#assign TypeName = resolveTypeName(member.type)
         MemName  = getElementName(member)
         MemVar   = getElementVarName(member)>
<#if member?is_first>

        //////////////////////////////////////////////
        // Elements
</#if>
<#if isListMember(member) >                  

        inline int get${MemName}Count() const { return ${resolveListSize( MemVar )}; }
    <#if member.type.usage == "ByPointer">
        inline ${resolveConstPtrRefType(member.type)} ${getElementGetter(member)}(int index) const { return ${resolveListGet( MemVar, "index")}; }
        inline ${resolvePtrRefType(member.type)} ${getElementGetter(member)}(int index)       { return ${resolveListGet( MemVar, "index")}; }
      <#if options.generate.setters == true>
        inline void add${MemName}(${resolvePtrRefType(member.type)} item) { ${resolveListAdd( MemVar, "item")}; }
        inline void remove${MemName}(int index) { ${resolveListRemove( MemVar, "index")}; }
      </#if>
    <#elseif member.type.usage == "ByReference">
        inline ${TypeName} const & ${getElementGetter(member)}(int index) const { return ${resolveListGet( MemVar, "index")}; }
        inline ${TypeName} & ${getElementGetter(member)}(int index)       { return ${resolveListGet( MemVar, "index")}; }
      <#if options.generate.setters == true>
        inline void add${MemName}(${TypeName} const & item) { ${resolveListAdd( MemVar, "item")}; }
        inline void remove${MemName}(int index) { ${resolveListRemove( MemVar, "index")}; }
      </#if>
    <#else>
        inline ${TypeName} const ${getElementGetter(member)}(int index) const { return ${resolveListGet( MemVar, "index")}; }
        inline ${TypeName} ${getElementGetter(member)}(int index)       { return ${resolveListGet( MemVar, "index")}; }
      <#if options.generate.setters == true>
        inline void add${MemName}(${TypeName} const item) { ${resolveListAdd( MemVar, "item")}; }
        inline void remove${MemName}(int index) { ${resolveListRemove( MemVar, "index")}; }
      </#if>
    </#if>
<#else>

   <#if member.type.usage == "ByPointer">
        inline ${resolveConstPtrRefType(member.type)} ${getElementGetter(member)}() const { return ${MemVar}; }
        inline ${resolvePtrRefType(member.type)} ${getElementGetter(member)}()       { return ${MemVar}; }
    <#if options.generate.setters == true>
        inline void ${getElementSetter(member)}(${resolvePtrRefType(member.type)} p)  { ${MemVar} = p; ${insertSetFlagCheck("p")}}
    </#if>
   <#elseif member.type.usage == "ByReference">
        inline ${TypeName} const & ${getElementGetter(member)}() const { return ${MemVar}; }
        inline ${TypeName}       & ${getElementGetter(member)}()       { return ${MemVar}; }
      <#if options.generate.setters == true>
        inline void ${getElementSetter(member)}(${TypeName} &r)  { ${MemVar} = r; ${insertSetFlag()}}
      </#if>
   <#else>
        inline ${TypeName} get${MemName}() const { return ${MemVar}; }
      <#if options.generate.setters == true>
        inline void ${getElementSetter(member)}(${TypeName} v)  { ${MemVar} = v; ${insertSetFlag()}}
      </#if>
   </#if>
   <#if options.generate.setflags>
        inline void ${getElementClear(member)}() { setFlags.reset( ${memberIndex} ); }
        inline bool ${getElementIsSet(member)}() const { return setFlags.test( ${memberIndex} ); }
      <#assign memberIndex = memberIndex + 1 >
   </#if>       

</#if>
</#list>
<#if type.mixed >
        inline ${resolveTypeName( string.type )} const & getContent() const { return mixedContent; }
   <#if options.generate.setflags>
        inline bool isContentSet() const { return setFlags.test( ${memberIndex} ); }
   </#if> 
   <#if options.generate.setters == true>
        inline void addContent( ${resolveTypeName( string.type )} const & c ) { mixedConent.append( c ); ${insertSetFlag() }
        
        inline void clearContent(int index) 
        { 
     <#if options.generate.setflags>
           setFlags.reset( ${memberIndex} );
     </#if>
           mixedContent.clear();
        }
   </#if>
   <#if options.generate.setflags>
      <#assign memberIndex = memberIndex + 1 >
   </#if>
</#if>     
</#if>
 <#if options.generate.member.protection == true>

    protected:
</#if>
        
<#list type.attributes as attribute>
 <#assign MemName  = getAttributeName(attribute)>
 <#assign MemVar   = getAttributeVarName(attribute) >
 <#if attribute.type.usage == "ByPointer">
        ${resolvePtrType(attribute.type)?right_pad(mpad)} ${MemVar};
 <#else>
        ${resolveTypeName(attribute.type)?right_pad(mpad)} ${MemVar};
 </#if>
</#list>     
<#list type.members as member>
 <#assign TypeName = resolveTypeName(member.type)>
 <#assign MemName  = getElementName(member)>
 <#assign MemVar   = getElementVarName(member) >
 <#if ((member.documentation.lines?size) > 1) >
  <#list member.documentation.lines as docLine>
    <#if docLine?is_first>
 
        /**
    </#if>
         * ${c_comment_string(docLine)}
    <#if docLine?is_last>
         */
    </#if>
  </#list>
 <#else>
  <#if ((member.documentation.lines?size) > 0) >

        /** ${c_comment_string(member.documentation.lines[0])} */       
  </#if>
 </#if>
 <#if isListMember(member)>
        
    <#if member.type.usage == "ByPointer">
        ${resolveListPtrType(member.type)?right_pad(mpad)} ${MemVar};
    <#else>
        ${resolveListType(member.type)?right_pad(mpad)} ${MemVar};
    </#if>
 <#else>
    <#if member.type.usage == "ByPointer">
        ${resolvePtrType(member.type)?right_pad(mpad)} ${MemVar};
    <#else>
        ${TypeName?right_pad(mpad)} ${MemVar};
    </#if>
 </#if>
</#list>
<#if type.mixed >
        ${resolveTypeName( string.type )?right_pad(mpad)} mixedContent;
</#if>
<#if options.generate.setflags>
        
        ::std::bitset<${memberIndex}> setFlags;
</#if> 
</#if>
     };    
 } // End of name-space ${type.namespace.name} 
 
 #endif