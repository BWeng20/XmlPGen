<#--
  Copyright (c) 2013-2016 Bernd Wengenroth
  Licensed under the MIT License.
  See LICENSE file for details.
-->
<#include "../HelperFunctions.fm">
<#assign Clazz = type.TypeHPP.GName>
/************************************
 * ${file.name}
 *
 * Parser binder for ${type.namespace.uri} ${type.name}
 *
 * Implementation
 *
 * Generated by XmlPGen (c) 2013-2016 Bernd Wengenroth
 * ${timestamp()}   
 */

#include ${MakeLocalPath(type.SchemaHPP.GPath)}
#include "XmlPGen/TTypeProxy.h"
#include "XmlPGen/Log.h"

namespace ${namespace.name}
{
   // anonymous namespace to hide all internal symbols.
   namespace {
   
    class ${type.GName} : public ::XmlPGen::TypeHandler
    {
    public:
     explicit ${type.GName}( ${Clazz} * obj )
     : obj_ { obj }
     {}
     
     ::XmlPGen::TypeHandler * addAttribute(int token) override
     {
<#if ((type.attributes?size)>0) >
       switch ( static_cast<EToken>(token) )
       {
<#list type.attributes as attribute>
<#assign MemVar   = getAttributeVarName(attribute)
         TypeName = resolveTypeNameFromTemplate(attribute.type, "TypeHPP")>
       case EToken::${attribute.name?capitalize}:
 <#if options.generate.getters == true && options.generate.member.protection == true>
  <#if options.generate.setters == true>
    <#if attribute.type.usage == "ByPointer">
           return ::XmlPGen::TTypeProxy< ${TypeName} >::createHandler( &${resolvePtrDeRef( "obj_->"+getAttributeGetter(attribute)+"()")} );
    <#elseif attribute.type.usage == "ByReference">       
           return ::XmlPGen::TTypeProxy< ${TypeName} >::createHandler( &(obj_->${getAttributeGetter(attribute)+"()"}) );
    <#else>
           return new ::XmlPGen::FunctionContentHandler( 
                      [=]( char const * str_value )
                      { 
                         ${resolveTypeName(attribute.type)} value;
                         ::XmlPGen::ParseString( str_value, value );
                         obj_->${getAttributeSetter(attribute)}( value );
                      } );
    </#if>
   <#else>
           // Adjust generator settings! 
           #error No setters for protected members available. Can't assign values.
   </#if>
 <#else>
           return ::XmlPGen::TTypeProxy< ${resolveTypeName(attribute.type)} >::createHandler( &${resolveAttributeGet(attribute,"obj_->")} );
 </#if>  
</#list>
       default:
           return nullptr;
       }
<#else>
       return nullptr;
</#if>       
     }
    
     ::XmlPGen::TypeHandler * addElement(int token) override
     {
<#if ((type.members?size)>0) >
       switch ( static_cast<EToken>(token) )
       {
<#list type.members as member>
 <#assign TypeName = resolveTypeNameFromTemplate(member.type, "TypeHPP")
          MemVar   = getElementVarName(member)
          MemName  = getElementName(member)>
       case EToken::${member.name?capitalize}: 
       {
 <#if options.generate.getters == true && options.generate.member.protection == true>
  <#if options.generate.setters == true>
    <#if isListMember(member) > 
        <#if member.type.usage == "ByPointer">
           obj_->add${getElementName(member)}( ${resolvePtrNewFromTemplate(member.type,"TypeHPP")} );
           return ::XmlPGen::TTypeProxy< ${TypeName} >::createHandler( ${resolvePtrGetPtr("obj_->"+getElementGetter(member)+"(obj_->get"+MemName+"Count()-1)")} );
        <#elseif member.type.usage == "ByReference">
           obj_->add${getElementName(member)}( ${TypeName}() );
           return ::XmlPGen::TTypeProxy< ${TypeName} >::createHandler( &(obj_->${getElementGetter(member)}( obj_->get${MemName}Count()-1 ) );
        <#else>
           ${resolveType(member.type)} val;
           // TODO dynamic stetter needed to new added list element
        </#if>
    <#else>
        <#if member.type.usage == "ByPointer">
           return ::XmlPGen::TTypeProxy< ${TypeName} >::createHandler( &${resolvePtrDeRef( "obj_->"+getElementGetter(member)+"()")} );
        <#elseif member.type.usage == "ByReference">       
           return ::XmlPGen::TTypeProxy< ${TypeName} >::createHandler( &(obj_->${getElementGetter(member)+"()"}) );
        <#else>
           return new ::XmlPGen::FunctionContentHandler( 
                      [=]( char const * str_value )
                      { 
                         ${resolveTypeName(member.type)} value;
                         ::XmlPGen::ParseString( str_value, value );
                         obj_->${getElementSetter(member)}( value );
                      } );

        </#if>
    </#if>
   <#else>
           // Adjust generator settings! 
           #error No setters for protected members available.
           break;
   </#if>
 <#else>
    <#if isListMember(member) > 
           obj_->${resolveListAdd( MemVar, TypeName+"()" )};
           return ::XmlPGen::TTypeProxy< ${TypeName} >::createHandler( &${resolveListGetLast("obj_->"+MemVar)} );
    <#else>
           return ::XmlPGen::TTypeProxy< ${TypeName} >::createHandler( &${resolveElementGet(member,"obj_->")} );
    </#if>
 </#if>  
       }
</#list>
       default:
           return nullptr;
       }
<#else>
       return nullptr;
</#if>       
     }

     void addContent(char const *<#if type.mixed >value</#if>) override
     {
<#if type.mixed >
   <#if options.generate.setters == true>
        obj_->addContent( value );
   <#elseif options.generate.member.protection == false>
        obj_->mixedContent.append( value );
   <#else>
        // Adjust generator settings! 
        #error No setter for protected members available. Can't assign value.
   </#if>
<#else>
        // not mixed 
</#if>
     }
     
     ${Clazz} * obj_;
    };
   }

} // End of namespace ${namespace.name} 

namespace XmlPGen
{
   template<>
   TypeHandler * TTypeProxy< ${namespace.name}::${Clazz} >::createHandler( ${namespace.name}::${Clazz} * o)
   {
       return o ? new ${namespace.name}::${type.GName}(o) : nullptr;
   }
}
