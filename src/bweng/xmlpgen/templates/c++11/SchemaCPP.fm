<#--
  Copyright (c) 2016 Bernd Wengenroth
  Licensed under the MIT License.
  See LICENSE file for details.
-->
<#include "HelperFunctions.fm">
<#assign Clazz = namespace.GName>
/************************************
 * ${file.name}
 *
 * Schema Object for ${namespace.uri}
 *
 * Implementation
 *
<#list namespace.documentation.lines as docLine>
 * ${c_comment_string(docLine)}
</#list>
 *
 * Generated by XmlPGen (c) 2013-2016 Bernd Wengenroth
 * ${timestamp()}   
 */
#include ${MakeLocalPath(namespace.SchemaHPP.GPath)}
#include "XmlPGen/TTypeProxy.h"
 
namespace ${NAMESPACE}
{

   static ::XmlPGen::TokenMap const sTokenMap 
   {
     <#list namespace.lookup.chars?chunk(5) as charline>
     <#list charline as tc>{${tc.char?switch('\x0',' 0 ',"'"+tc.char+"'")}, ${tc.next?left_pad(3)}, ${tc.id?left_pad(3)} }<#sep>,</#list><#sep>,
     </#list>
   };

   ${Clazz}::${Clazz}()
   : Schema( ${c_string(namespace.uri)} )
   {
   }

   ::XmlPGen::TypeHandler * ${Clazz}::createRootHandler() const
   {
     root = ${resolvePtrNewFromTemplate(namespace.root.type, "TypeHPP")};
     return XmlPGen::TTypeProxy< ${resolveTypeNameFromTemplate( namespace.root.type, "TypeHPP" )} >::createHandler( ${resolvePtrGetPtr("root")});
   }
    
   ::XmlPGen::TokenChar const * ${Clazz}::getTokenMap() const
   { 
      return sTokenMap;
   }

} // End of namespace ${namespace.name} 
 