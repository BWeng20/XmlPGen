<#--
  Copyright (c) 2016 Bernd Wengenroth
  Licensed under the MIT License.
  See LICENSE file for details.
-->
<#include "HelperFunctions.fm">
<#assign Clazz = type.GName>
/************************************
 * ${file.name}
 *
 * Data Object for ${c_comment_string(type.namespace.uri)} ${type.name}
 *
 * Implementation
 *
<#list type.documentation.lines as docLine>
 * ${c_comment_string(docLine)}
</#list>
 *
 * Generated by XmlPGen (c) 2013 - 2016 Bernd Wengenroth
 * ${timestamp()}   
 */
 #include ${MakeLocalPath(type.TypeHPP.GPath)}
<#if type.isEnumeration>
 #include <map>
</#if>
<#if options.generate.setflags >
  <#-- Detect if and how many "set" flags are needed -->
  <#assign SetMemberCount = type.attributes?size >
  <#list type.members as member>
    <#if ! isListMember(member) >
      <#assign SetMemberCount = SetMemberCount+1 >
    </#if>
  </#list>
  <#assign setMemberIndex = 0 >
<#else>
  <#assign SetMemberCount = 0 >
</#if> 

 namespace ${type.namespace.name}
 {
<#if type.isEnumeration>
    typedef ::std::map< ::std::string, int32_t > tnames_to_enums;
    static tnames_to_enums _names_to_enums =
    {<#list type.enumeration.values?sort_by("value") as enumValue>{"${enumValue.value}", static_cast<int32_t>(${Clazz}::${enumValue.GEValue}) }<#sep>,</#list>};

    ${Clazz}::Type ${Clazz}::parse( char const * const _name )
    {
        tnames_to_enums::const_iterator const & _it  = _names_to_enums.find( _name );
        if ( _it != _names_to_enums.end() ) return static_cast<${Clazz}::Type>(_it->second);
        return UNSET;
    }

    char const * ${Clazz}::toString( Type val )
    {
        switch( val )
        {
<#assign epad = max(16,type.enumeration.maxlength)>
<#list type.enumeration.values as enumValue>
           case ${(enumValue.GEValue+":")?right_pad(epad+1)} return "${enumValue.value}";
</#list>
           case NUMBER_OF_VALUES:
           case UNSET:            return "";
        }
        return "";
    }
<#else>

<#if options.generate.ctor == true>
	${Clazz}::${Clazz}()
<#assign ds=":">
<#list type.attributes as attribute>
<#assign MemVar  = getAttributeVarName(attribute)>
 <#if attribute.type.usage == "ByPointer">
	${ds}<#assign ds=","> ${MemVar}(nullptr)
 <#else>
	${ds}<#assign ds=","> ${MemVar}()	
 </#if>
</#list> 	
<#list type.members as member>
<#if !isListMember(member)>
<#assign MemVar = getElementVarName(member)>
 <#if member.type.usage == "ByPointer">
	${ds}<#assign ds=","> ${MemVar}(0)	
 <#else>
	${ds}<#assign ds=","> ${MemVar}()	
 </#if>
</#if>
</#list>
	{
	}
</#if>
<#if options.generate.copyctor == true>
	
	${Clazz}::${Clazz}( const ${Clazz} & r)
<#assign ds=":">
<#list type.attributes as attribute>
<#assign MemVar = getAttributeVarName(attribute)>
	${ds}<#assign ds=","> ${MemVar}( r.${MemVar} )
</#list> 	
<#list type.members as member>
<#assign MemVar = getElementVarName(member)>
	${ds}<#assign ds=","> ${MemVar}( r.${MemVar} )
</#list>
<#if (SetMemberCount>0) >
   , setFlags( r.setFlags )
</#if> 
	{
	}
</#if>
<#if options.generate.assignment == true>

	${Clazz} & ${Clazz}::operator = (const ${Clazz} & r)
	{
		if ( this != &r )
		{
<#if (SetMemberCount>0) >
         setFlags = r.setFlags;
</#if>
<#list type.attributes as attribute>
  <#assign MemVar = getAttributeVarName(attribute)>
			${MemVar} = r.${MemVar};
</#list>
<#list type.members as member>
<#assign MemVar = getElementVarName(member)>
			${MemVar} = r.${MemVar};
</#list>
		}
		return *this;
	}
</#if>
 <#if options.generate.compare == true>
 
	bool ${Clazz}::operator == (const ${Clazz} & r) const
	{
		return
<#assign ds        ="  "
         CndPrefix = "" 
         CndPostfix= "">
<#if (SetMemberCount>0) >
       ${ds}<#assign ds="&&"> setFlags == r.setFlags
</#if>
<#list type.attributes as attribute>
<#assign MemVar = getAttributeVarName(attribute)>
 <#if (SetMemberCount>0) >
  <#assign CndPrefix = "((!setFlags.test("+ setMemberIndex +")) || "
           CndPostfix= ")"
           setMemberIndex = setMemberIndex+1 >
 </#if>
 <#if attribute.type.usage == "ByPointer">
       ${ds}<#assign ds="&&"> ${CndPrefix}((r.${MemVar} && ${MemVar})?(*r.${MemVar}==*${MemVar}):(r.${MemVar}==${MemVar}))${CndPostfix}
 <#else>
       ${ds}<#assign ds="&&"> ${CndPrefix}(r.${MemVar}==${MemVar})${CndPostfix}
 </#if>
</#list> 	
<#list type.members as member>
<#assign MemVar = getElementVarName(member)>
 <#if (SetMemberCount>0) >
  <#assign CndPrefix = "((!setFlags.test("+ setMemberIndex +")) || "
           CndPostfix= ")"
           setMemberIndex = setMemberIndex+1 >
 </#if>
 <#if !isListMember(member)>
  <#if member.type.usage == "ByPointer">
		 ${ds}<#assign ds="&&"> ${CndPrefix}((r.${MemVar} && ${MemVar})?(*r.${MemVar}==*${MemVar}):(r.${MemVar}==${MemVar}))${CndPostfix}
  <#else>
		 ${ds}<#assign ds="&&"> ${CndPrefix}(r.${MemVar}==${MemVar})${CndPostfix}
  </#if>
 <#else>
		 ${ds}<#assign ds="&&"> ${CndPrefix}(r.${MemVar}==${MemVar})${CndPostfix}
 </#if>
 </#list>
		 ;
	}
</#if>
</#if>
 } // End of namespace ${type.namespace.name} 
 