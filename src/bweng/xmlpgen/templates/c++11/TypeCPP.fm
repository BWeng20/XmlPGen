<#--
  Copyright (c) 2016 Bernd Wengenroth
  Licensed under the MIT License.
  See LICENSE file for details.
-->
<#include "HelperFunctions.fm">
<#assign Clazz = type.GName>
/************************************
 * ${file.name}
 *
 * Data Object for ${c_comment_string(type.namespace.uri)} ${type.name}
 *
 * Implementation
 *
<#list type.documentation.lines as docLine>
 * ${c_comment_string(docLine)}
</#list>
 *
 * Generated by XmlPGen (c) 2013 - 2016 Bernd Wengenroth
 * ${timestamp()}   
 */
 #include ${MakeLocalPath(type.TypeHPP.GPath)}
<#if type.isEnumeration>
 #include <map>
</#if>

 namespace ${type.namespace.name}
 {
<#if type.isEnumeration>
    typedef ::std::map< ::std::string, int32_t > tnames_to_enums;
    static tnames_to_enums _names_to_enums =
    {<#list type.enumeration.values?sort_by("value") as enumValue>{"${enumValue.value}", static_cast<int32_t>(${Clazz}::${enumValue.GEValue}) }<#sep>,</#list>};

    ${Clazz}::Type ${Clazz}::parse( char const * const _name )
    {
        tnames_to_enums::const_iterator const & _it  = _names_to_enums.find( _name );
        if ( _it != _names_to_enums.end() ) return static_cast<${Clazz}::Type>(_it->second);
        return UNSET;
    }

    char const * ${Clazz}::toString( Type val )
    {
        switch( val )
        {
<#assign epad = max(16,type.enumeration.maxlength)>
<#list type.enumeration.values as enumValue>
           case ${(enumValue.GEValue+":")?right_pad(epad+1)} return "${enumValue.value}";
</#list>
           case NUMBER_OF_VALUES:
           case UNSET:            return "";
        }
        return "";
    }
<#else>

<#if options.generate.ctor == true>
	${Clazz}::${Clazz}()
<#assign ds=":">
<#list type.attributes as attribute>
<#assign TypeName = resolveTypeName(attribute.type)
         MemName  = getAttributeName(attribute)
         MemVar   = getAttributeVarName(attribute)>
 <#if attribute.type.usage == "ByPointer">
	${ds}<#assign ds=","> ${MemVar}(0)
 <#else>
	${ds}<#assign ds=","> ${MemVar}()	
 </#if>
</#list> 	
<#list type.members as member>
<#if !isListMember(member)>
<#assign TypeName = resolveTypeName(member.type)
         MemName  = getElementName(member)
         MemVar   = getElementVarName(member)>
 <#if member.type.usage == "ByPointer">
	${ds}<#assign ds=","> ${MemVar}(0)	
 <#else>
	${ds}<#assign ds=","> ${MemVar}()	
 </#if>
</#if>
</#list>
	{
	}
</#if>
<#if options.generate.copyctor == true>
	
	${Clazz}::${Clazz}( const ${Clazz} & r)
<#assign ds=":">
<#list type.attributes as attribute>
<#assign TypeName = resolveTypeName(attribute.type)
         MemName  = getAttributeName(attribute)
         MemVar   = getAttributeVarName(attribute)>
	${ds}<#assign ds=","> ${MemVar}( r.${MemVar} )
</#list> 	
<#list type.members as member>
<#assign TypeName = resolveTypeName(member.type)
         MemName  = getElementName(member)
         MemVar   = getElementVarName(member)>
	${ds}<#assign ds=","> ${MemVar}( r.${MemVar} )
</#list>
	{
	}
</#if>
<#if options.generate.assignment == true>

	${Clazz} & ${Clazz}::operator = (const ${Clazz} & r)
	{
		if ( this != &r )
		{
<#list type.attributes as attribute>
<#assign TypeName = resolveTypeName(attribute.type)
         MemName  = getAttributeName(attribute)
         MemVar   = getAttributeVarName(attribute)>
			${MemVar} = r.${MemVar};
</#list> 	
<#list type.members as member>
<#assign TypeName = resolveTypeName(member.type)
         MemName  = getElementName(member)
         MemVar   = getElementVarName(member)>
<#if !isListMember(member)>
			${MemVar} = r.${MemVar};
<#else>
			${MemVar} = r.${MemVar};
</#if>
</#list>
		}
		return *this;
	}
</#if>
 <#if options.generate.compare == true>
 
	bool ${Clazz}::operator == (const ${Clazz} & r) const
	{
		return
<#assign ds="  ">
<#list type.attributes as attribute>
<#assign TypeName = resolveTypeName(attribute.type)
         MemName  = getAttributeName(attribute)
         MemVar   = getAttributeVarName(attribute)>
 <#if attribute.type.usage == "ByPointer">
		 ${ds}<#assign ds="&&"> ((r.${MemVar} && ${MemVar})?(*r.${MemVar}==*${MemVar}):(r.${MemVar}==${MemVar}) )
 <#else>
		 ${ds}<#assign ds="&&"> (r.${MemVar}==${MemVar})
 </#if>
</#list> 	
<#list type.members as member>
<#assign TypeName = resolveTypeName(member.type)
         MemName  = getElementName(member)
         MemVar   = getElementVarName(member)>
<#if !isListMember(member)>
 <#if member.type.usage == "ByPointer">
		 ${ds}<#assign ds="&&"> ((r.${MemVar} && ${MemVar})?(*r.${MemVar}==*${MemVar}):(r.${MemVar}==${MemVar}) )
 <#else>
		 ${ds}<#assign ds="&&"> (r.${MemVar}==${MemVar})
 </#if>
<#else>
		 ${ds}<#assign ds="&&"> (r.${MemVar}==${MemVar})
</#if></#list>
		 ;
	}
</#if>
</#if>
 } // End of namespace ${type.namespace.name} 
 